# -*- coding: utf-8 -*-
"""Lab3.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1__h3Gt0rJaVCtOv2kz3m-8Wr-fUv-fdP
"""

BFS AND DFS

from collections import deque   # import deque at the top

# Step 1: Graph data (Adjacency List)
pakistan_cities = {
    'Karachi': ['Hyderabad'],
    'Hyderabad': ['Karachi', 'Sukkur'],
    'Sukkur': ['Hyderabad', 'Multan', 'Quetta'],
    'Multan': ['Sukkur', 'Lahore'],
    'Quetta': ['Sukkur'],
    'Lahore': ['Multan', 'Islamabad'],
    'Islamabad': ['Lahore', 'Peshawar'],
    'Peshawar': ['Islamabad']
}

# Step 2: BFS Implementation (Shortest Path)
def bfs_shortest_path(graph, start, goal):
    queue = deque([[start]])  # Start with a path containing only the start node
    visited = set()

    while queue:
        path = queue.popleft()
        current_city = path[-1]

        if current_city == goal:
            return path

        if current_city not in visited:
            visited.add(current_city)
            for neighbor in graph.get(current_city, []):
                new_path = list(path)
                new_path.append(neighbor)
                queue.append(new_path)

    return None  # No path found

# Step 3: DFS Implementation (Any Path)
def dfs_path(graph, start, goal, path=None, visited=None):
    if path is None:
        path = []
    if visited is None:
        visited = set()

    path.append(start)
    visited.add(start)

    if start == goal:
        return path

    for neighbor in graph.get(start, []):
        if neighbor not in visited:
            result = dfs_path(graph, neighbor, goal, path.copy(), visited.copy())
            if result:
                return result

    return None  # No path found

# Step 4: Ask the user for start and goal cities
print("Available cities:", ", ".join(pakistan_cities.keys()))
start_city = input("Enter the start city: ").strip()
goal_city = input("Enter the goal city: ").strip()

# Check if start and goal exist in the graph
if start_city not in pakistan_cities or goal_city not in pakistan_cities:
    print("One or both cities not found in the graph.")
else:
    # BFS for the shortest path
    bfs_result = bfs_shortest_path(pakistan_cities, start_city, goal_city)
    print(f"BFS Shortest Path from {start_city} to {goal_city}:", bfs_result)

    # DFS for any path
    dfs_result = dfs_path(pakistan_cities, start_city, goal_city)
    print(f"DFS Path from {start_city} to {goal_city}:", dfs_result)